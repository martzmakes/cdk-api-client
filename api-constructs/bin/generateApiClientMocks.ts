/* eslint-disable @typescript-eslint/require-await */
import * as fs from "fs";
import * as path from "path";
import * as ts from "typescript";

/**
 * Interface for endpoint mock information
 */
interface EndpointMock {
  name: string;
  paramType: string;
  returnType: string;
}

/**
 * Represents an import statement for a type
 */
interface TypeImport {
  typeName: string;
  importPath: string;
}

/**
 * Parses a TypeScript file and extracts API client method information
 */
function parseApiClientFile({
  titleCaseProjectName,
  filePath,
}: {
  titleCaseProjectName: string;
  filePath: string;
}): {
  endpoints: EndpointMock[];
  imports: TypeImport[];
} {
  const fileContent = fs.readFileSync(filePath, "utf8");
  const sourceFile = ts.createSourceFile(
    filePath,
    fileContent,
    ts.ScriptTarget.Latest,
    true
  );

  const endpoints: EndpointMock[] = [];
  const imports: TypeImport[] = [];

  // Function to recursively visit nodes
  function visit(node: ts.Node) {
    // Collect import statements
    if (ts.isImportDeclaration(node)) {
      const importPath = (node.moduleSpecifier as ts.StringLiteral).text;

      // Process named imports
      if (
        node.importClause?.namedBindings &&
        ts.isNamedImports(node.importClause.namedBindings)
      ) {
        node.importClause.namedBindings.elements.forEach((element) => {
          const typeName = element.name.text;
          imports.push({ typeName, importPath });
        });
      }
    }

    // Looking for method declarations inside the ApiClient class
    if (
      ts.isMethodDeclaration(node) &&
      node.parent &&
      ts.isClassDeclaration(node.parent) &&
      node.parent.name?.text === `${titleCaseProjectName}ApiClient`
    ) {
      const methodName = node.name.getText(sourceFile);

      // Skip constructor
      if (methodName === "constructor") {
        return;
      }

      // Get parameter type
      let paramType = "any";
      if (node.parameters.length > 0 && node.parameters[0].type) {
        paramType = node.parameters[0].type.getText(sourceFile);
      }

      // Get return type
      let returnType = "any";
      if (node.type) {
        returnType = node.type.getText(sourceFile);
        // Remove Promise wrapper if present
        if (returnType.startsWith("Promise<") && returnType.endsWith(">")) {
          returnType = returnType.substring(8, returnType.length - 1);
        }
      }

      endpoints.push({
        name: methodName,
        paramType,
        returnType,
      });
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return { endpoints, imports };
}

/**
 * Generates the mock client code based on endpoint information
 */
function generateMockClientCode({
  endpoints,
  imports,
  titleCaseProjectName,
}: {
  endpoints: EndpointMock[];
  imports: TypeImport[];
  titleCaseProjectName: string;
}): string {
  // Collect unique return types to import
  const returnTypes = new Set<string>();
  const typeToImportMap = new Map<string, string>();

  // Map type names to their import paths
  imports.forEach((imp) => {
    typeToImportMap.set(imp.typeName, imp.importPath);
  });

  // Collect return types
  endpoints.forEach((endpoint) => {
    const returnType = endpoint.returnType;
    if (returnType !== "any" && returnType !== "void") {
      returnTypes.add(returnType);
    }
  });

  // Group imports by path
  const importsByPath = new Map<string, Set<string>>();

  // Add ApiClient import
  importsByPath.set(
    "./apiClient",
    new Set([`${titleCaseProjectName}ApiClient`])
  );

  // Add other type imports
  returnTypes.forEach((type) => {
    // Extract type name - handling generics by taking the base type
    const baseType = type.split("<")[0].trim();

    if (typeToImportMap.has(baseType)) {
      const importPath = typeToImportMap.get(baseType)!;
      if (!importsByPath.has(importPath)) {
        importsByPath.set(importPath, new Set());
      }
      importsByPath.get(importPath)!.add(baseType);
    }
  });

  let mockCode = `
/**
 * Auto-generated API client mock for Jest testing
 * Do not edit this file directly
 */
`;

  // Generate import statements
  importsByPath.forEach((types, path) => {
    mockCode += `import { ${Array.from(types).join(", ")} } from '${path}';\n`;
  });

  mockCode += `
/**
 * Type for mock implementation of each endpoint
 */
export type MockImplementation<T> = jest.Mock<Promise<T>, [any]>;

/**
 * ApiClientMock class with Jest mock implementations for each endpoint
 */
export class ${titleCaseProjectName}ApiClientMock implements Partial<${titleCaseProjectName}ApiClient> {
`;

  // Generate mock properties for each endpoint
  endpoints.forEach((endpoint) => {
    mockCode += `  ${endpoint.name}: MockImplementation<${endpoint.returnType}> = jest.fn();\n`;
  });

  // Add reset method
  mockCode += `
  /**
   * Resets all mock implementations
   */
  resetMocks(): void {
`;

  endpoints.forEach((endpoint) => {
    mockCode += `    this.${endpoint.name}.mockReset();\n`;
  });

  mockCode += `  }

  /**
   * Clears all mocks
   */
  clearMocks(): void {
`;

  endpoints.forEach((endpoint) => {
    mockCode += `    this.${endpoint.name}.mockClear();\n`;
  });

  mockCode += `  }
}

/**
 * Creates an instance of the API client mock
 */
export function createApi${titleCaseProjectName}ClientMock(): ${titleCaseProjectName}ApiClientMock {
  return new ${titleCaseProjectName}ApiClientMock();
}
`;

  return mockCode;
}

/**
 * Generates a mock API client based on the generated API client
 */
export function generateApiClientMocks({
  apiClientPath,
  projectName,
  outputPath,
}: {
  apiClientPath: string;
  projectName: string;
  outputPath: string;
}): void {
  console.log(`Generating API client mocks from ${apiClientPath}...`);

  // Parse the API client file
  const { endpoints, imports } = parseApiClientFile({
    titleCaseProjectName:
      projectName.charAt(0).toUpperCase() + projectName.slice(1),
    filePath: path.join(apiClientPath, "apiClient.ts"),
  });

  if (endpoints.length === 0) {
    console.warn("No endpoints found in the API client.");
    return;
  }

  console.log(`Found ${endpoints.length} endpoints to mock.`);

  // Generate mock client code
  const mockCode = generateMockClientCode({
    endpoints,
    imports,
    titleCaseProjectName:
      projectName.charAt(0).toUpperCase() + projectName.slice(1),
  });

  // Write the generated mock to a file
  fs.writeFileSync(path.join(outputPath, "apiClientMock.ts"), mockCode);

  // Update index.ts to export the mock
  const indexPath = path.join(outputPath, "index.ts");
  let indexContent = fs.readFileSync(indexPath, "utf8");

  if (!indexContent.includes("apiClientMock")) {
    indexContent += `export * from './apiClientMock';\n`;
    fs.writeFileSync(indexPath, indexContent);
  }

  console.log(`API client mocks generated successfully in ${outputPath}`);
}

/**
 * Main function that runs when the script is executed directly
 */
async function main() {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.error(
      "Usage: ts-node generateApiClientMocks.ts <projectName> <generatedClientDir>"
    );
    process.exit(1);
  }

  const projectName = args[0];
  const generatedClientDir = args[1];

  try {
    generateApiClientMocks({
      apiClientPath: generatedClientDir,
      projectName,
      outputPath: generatedClientDir,
    });
  } catch (error) {
    console.error("Error generating API client mocks:", error);
    process.exit(1);
  }
}

// Run the main function if this script is executed directly
if (require.main === module) {
  main().catch((error) => {
    console.error("Unhandled error:", error);
    process.exit(1);
  });
}
