import { Endpoint } from "../../interfaces/Endpoint";

/**
 * Generates TypeScript code for the API client
 */
export function generateClientCode(
  endpointsDef: Record<string, Endpoint>,
  projectName: string
): string {
  const titleCaseProjectName =
    projectName.charAt(0).toUpperCase() + projectName.slice(1);

  // Collect all unique input and output types for imports
  const typeImports = new Set<string>();

  // Analyze endpoints for input/output types
  for (const [_, endpoint] of Object.entries(endpointsDef)) {
    const typedEndpoint = endpoint as Endpoint;

    // Add output type if it's a string (named type)
    if (
      typedEndpoint.output &&
      typeof typedEndpoint.output === "string" &&
      typedEndpoint.output !== "any" &&
      typedEndpoint.output !== "void"
    ) {
      typeImports.add(typedEndpoint.output);
    }

    // Add input type if it's a string (named type)
    if (
      typedEndpoint.input &&
      typeof typedEndpoint.input === "string" &&
      typedEndpoint.input !== "any" &&
      typedEndpoint.input !== "never"
    ) {
      typeImports.add(typedEndpoint.input);
    }
  }

  // Start building client code with imports
  let clientCode = `
/**
 * Auto-generated API client
 * Do not edit this file directly
 */
import { iamRequest } from '@martzmakes/constructs/lambda/iamRequest';
`;

  // Add imports for the collected types
  if (typeImports.size > 0) {
    clientCode += `
// Import types for inputs/outputs
`;
    typeImports.forEach((type) => {
      clientCode += `import { ${type} } from './interfaces/${type}';\n`;
    });
  }

  // Generate interfaces for the client
  clientCode += `
/**
 * Base parameters interface that all endpoint methods extend
 */
interface BaseParams {
  headers?: Record<string, string>;
  query?: Record<string, string>;
  [key: string]: any; // Add index signature to allow string indexing
}

`;

  // Generate types for each endpoint
  for (const [name, endpoint] of Object.entries(endpointsDef)) {
    const typedEndpoint = endpoint as Endpoint;

    // Extract path parameters
    const curlyParams = typedEndpoint.path.match(/{([a-zA-Z0-9_]+)}/g) || [];

    // Extract parameter names
    const pathParamNames = [
      ...curlyParams.map((param) => param.substring(1, param.length - 1)),
    ];

    // Determine the input type based on the endpoint definition
    let baseInterface = "BaseParams";

    // Create interface for this endpoint's parameters
    clientCode += `
/**
 * Parameters for ${name} endpoint
 */
export interface ${name.charAt(0).toUpperCase() + name.slice(1)}Params extends ${baseInterface} {
${pathParamNames.map((param) => `  ${param}: string | number;`).join("\n")}`;

    // Add body property for non-GET requests if there's an input type
    if (
      typedEndpoint.method !== "GET" &&
      typedEndpoint.input &&
      typedEndpoint.input !== "never"
    ) {
      const bodyType =
        typeof typedEndpoint.input === "string" ? typedEndpoint.input : "any";
      clientCode += `
  body: ${bodyType};`;
    }
    // Add query property for GET requests if there's an input type
    else if (
      typedEndpoint.method === "GET" &&
      typedEndpoint.input &&
      typedEndpoint.input !== "never"
    ) {
      const queryType =
        typeof typedEndpoint.input === "string" ? typedEndpoint.input : "any";
      clientCode += `
  query?: ${queryType};`;
    }

    clientCode += `
}

`;
  }

  // Create the API client class
  clientCode += `
/**
 * Generated API client
 */
export class ${titleCaseProjectName}ApiClient {
  private projectName: string;

  constructor(projectName: string = '${projectName}') {
    this.projectName = projectName;
  }

`;

  // Generate methods for each endpoint
  for (const [name, endpoint] of Object.entries(endpointsDef)) {
    const typedEndpoint = endpoint as Endpoint;

    // Determine the output type for the endpoint
    const outputType =
      typedEndpoint.output && typedEndpoint.output !== "any"
        ? typeof typedEndpoint.output === "string"
          ? typedEndpoint.output
          : "any"
        : "any";

    // Determine if endpoint has an input type
    const hasInputType =
      !!typedEndpoint.input && typedEndpoint.input !== "never";

    // Method implementation
    clientCode += `
  /**
   * ${name} API method
   * @path ${typedEndpoint.path}
   * @method ${typedEndpoint.method}
   */
  async ${name}(params: ${name.charAt(0).toUpperCase() + name.slice(1)}Params): Promise<${outputType}> {
    const { path, method } = ${JSON.stringify({ path: typedEndpoint.path, method: typedEndpoint.method })};
    
    // Replace path parameters with values from params
    let finalPath = path;
    
    // Handle curly bracket parameters
    const curlyPathParams = path.match(/{([a-zA-Z0-9_]+)}/g) || [];
    for (const param of curlyPathParams) {
      const paramName = param.substring(1, param.length - 1); // Remove curly braces
      if (params[paramName] === undefined) {
        throw new Error(\`Missing required path parameter: \${paramName}\`);
      }
      finalPath = finalPath.replace(param, encodeURIComponent(String(params[paramName])));
    }
    
    // Extract query parameters
    const query = params.query || (method === 'GET' ? {} : undefined);
    `;

    // Only include body code for non-GET requests that have an input type
    if (typedEndpoint.method !== "GET" && hasInputType) {
      clientCode += `
    // Extract body from params
    const body = params.body;
    `;
    }

    clientCode += `
    // Make the request using iamRequest
    const response = await iamRequest<${outputType}>({
      domain: process.env[this.projectName]!,
      path: finalPath,
      method,
      query,`;

    // Only include body in the request parameters if it's needed
    if (typedEndpoint.method !== "GET" && hasInputType) {
      clientCode += `
      body: JSON.stringify(body),`;
    }

    clientCode += `
      headers: params.headers || {
        'Content-Type': 'application/json',
      },
    });

    // Check if response is an empty object and throw error if it is
    if (response && typeof response === 'object' && 
        Object.keys(response).length === 0 && 
        Object.getPrototypeOf(response) === Object.prototype) {
      throw new Error('Received empty response from iamRequest');
    }

    return response as ${outputType};
  }
`;
  }

  // Close the class
  clientCode += `
}

/**
 * Creates and returns a configured API client
 */
export function create${titleCaseProjectName}ApiClient(projectName: string = '${projectName}'): ${titleCaseProjectName}ApiClient {
  return new ${titleCaseProjectName}ApiClient(projectName);
}
`;

  return clientCode;
}
