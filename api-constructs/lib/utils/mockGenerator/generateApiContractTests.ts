import * as fs from "fs";
import * as path from "path";
import { Endpoint } from "../../interfaces/Endpoint";

/**
 * Generates API contract tests between actual handlers and mocks
 * to ensure they are in sync
 */
export function generateApiContractTests({
  endpointsDef,
  projectName,
  outputDir,
}: {
  endpointsDef: Record<string, Endpoint>;
  projectName: string;
  outputDir: string;
}): void {
  console.log(`Generating API contract tests for ${projectName}...`);

  const titleCaseProjectName = projectName.charAt(0).toUpperCase() + projectName.slice(1);

  // Create imports for all types used in endpoints
  const typeImports = new Set<string>();
  
  // Collect all types needed for imports
  Object.values(endpointsDef).forEach(endpoint => {
    if (endpoint.input && endpoint.input !== 'never') {
      const inputType = endpoint.input.split('.').pop() || '';
      typeImports.add(inputType);
    }
    if (endpoint.output && endpoint.output !== 'any' && endpoint.output !== 'void') {
      const outputType = endpoint.output.split('.').pop() || '';
      typeImports.add(outputType);
    }
  });

  // Generate type imports
  const typeImportStatements = Array.from(typeImports)
    .map(type => `import { ${type} } from './interfaces/${type}';`)
    .join('\n');

  // Generate handler type check imports
  const handlerTypeCheckImports = `
import * as fs from 'fs';
import * as path from 'path';`;

  // Generate the test file content
  const testContent = `
import { ${titleCaseProjectName}ApiClient } from './apiClient';
import { ${titleCaseProjectName}ApiClientMock, createApi${titleCaseProjectName}ClientMock } from './apiClientMock';
${typeImportStatements}${handlerTypeCheckImports}

/**
 * Auto-generated contract tests to ensure API handlers and mocks are in sync
 * DO NOT EDIT THIS FILE DIRECTLY
 */
describe('API Contract Tests for ${titleCaseProjectName}ApiClient', () => {
  const mockClient = createApi${titleCaseProjectName}ClientMock();
  
  // Test that all methods from the actual client exist in the mock
  test('All API methods have corresponding mocks', () => {
    // Get all methods from the ApiClient prototype (excluding constructor and internal methods)
    const apiMethods = Object.getOwnPropertyNames(${titleCaseProjectName}ApiClient.prototype)
      .filter(method => 
        method !== 'constructor' && 
        !method.startsWith('_') && 
        typeof (${titleCaseProjectName}ApiClient.prototype as any)[method] === 'function'
      );
      
    // Check each API method exists in the mock
    apiMethods.forEach(method => {
      expect(mockClient).toHaveProperty(method);
      expect(typeof (mockClient as any)[method]).toBe('function');
    });
  });

  // Test for each specific endpoint
${Object.entries(endpointsDef)
  .map(([name, endpoint]) => {
    const inputType = endpoint.input && endpoint.input !== 'never' ? endpoint.input.split('.').pop() : 'never';
    const outputType = endpoint.output && endpoint.output !== 'any' && endpoint.output !== 'void' ? endpoint.output.split('.').pop() : 'void';
    
    // Generate appropriate mock input based on endpoint path and method
    let mockInput = '';
    
    // Extract path parameters
    const pathParams = (endpoint.path.match(/{([^}]+)}/g) || [])
      .map(param => param.slice(1, -1));
    
    if (pathParams.length > 0) {
      // If path has parameters, create an object with them
      const paramsObj = pathParams.reduce((acc, param) => {
        acc[param] = `"test-${param}"`;
        return acc;
      }, {} as Record<string, string>);
      
      // Add body parameter for POST/PUT methods
      if (endpoint.method === 'POST' || endpoint.method === 'PUT') {
        paramsObj.body = '{ /* Add appropriate test body here */ }';
        if (inputType && inputType !== 'never') {
          paramsObj.body = `{} as ${inputType}`;
        }
      }
      
      mockInput = JSON.stringify(paramsObj, null, 4)
        .replace(/"([^"]+)":/g, '$1:') // Remove quotes from property names
        .replace(/"/g, '\''); // Use single quotes for values
    } else if (endpoint.method === 'POST' || endpoint.method === 'PUT') {
      // For POST/PUT with no path params but with input
      mockInput = `{ body: ${inputType !== 'never' ? `{} as ${inputType}` : '{}'} }`;
    } else {
      // For endpoints with no params
      mockInput = '{}';
    }
    
    const handlerTypesCheck = `
  describe('${name} handler implementation', () => {
    test('handler uses correct interface types from endpoint definition', () => {
      // This test checks that the handler implementation is using the correct types
      // defined in the endpoint configuration
      
      let handlerFilePath = '';
      
      // Try to find the handler file by checking the endpoint entry (typical location)
      // Look for the path in the current workspace
      const entryPaths = process.env.ENDPOINT_ENTRIES ? 
        JSON.parse(process.env.ENDPOINT_ENTRIES) : {};
      
      handlerFilePath = entryPaths['${name}'] || '';
      
      // Check if handler file path was found
      expect(handlerFilePath).toBeTruthy();
      
      // Check if the file exists
      const fileExists = fs.existsSync(handlerFilePath);
      expect(fileExists).toBe(true);
      
      // Read the handler file
      const handlerContent = fs.readFileSync(handlerFilePath, 'utf8');
      
      // Check if the handler content uses the expected types
      ${inputType !== 'never' ? 
        `// Check if the handler uses the correct input type
        const hasCorrectInputType = new RegExp(\`ApiHandler\\\\s*<\\\\s*${inputType}\\\\b|ApiHandler\\\\s*<\\\\s*[^,>]*,\\\\s*[^,>]*,\\\\s*${inputType}\\\\b\`).test(handlerContent);
        expect(hasCorrectInputType).toBe(true);` : 
        `// For endpoints without input type, check that it's using a suitable placeholder
        const hasCorrectInputType = /ApiHandler\\s*<\\s*(never|undefined|any|void)\\b/.test(handlerContent);
        expect(hasCorrectInputType).toBe(true);`}
      
      ${outputType !== 'void' && outputType !== 'any' ? 
        `// Check if the handler uses the correct output type
        const hasCorrectOutputType = new RegExp(\`ApiHandler\\\\s*<[^>]*,\\\\s*${outputType}\\\\b|ApiHandler\\\\s*<[^,>]*,\\\\s*[^,>]*,\\\\s*[^,>]*,\\\\s*${outputType}\\\\b\`).test(handlerContent);
        expect(hasCorrectOutputType).toBe(true);` : 
        `// Output type check not necessary for void or any return types`}
    });
  });`;
    
    const mockImplementationTest = `
  describe('${name} endpoint', () => {
    test('mock properly implements the ${name} method', () => {
      // The mock should be a Jest mock function
      expect(jest.isMockFunction(mockClient.${name})).toBe(true);
      
      // Set up a mock implementation that returns expected data type
      ${outputType !== 'void' ? 
        `const mockResponse: ${outputType} = {} as ${outputType};
      mockClient.${name}.mockResolvedValue(mockResponse);` : 
        `mockClient.${name}.mockResolvedValue(undefined);`}
      
      // Verify the mock can be called with the expected input type
      const input = ${mockInput};
      return mockClient.${name}(input).then(result => {
        ${outputType !== 'void' ? 'expect(result).toBe(mockResponse);' : ''}
        expect(mockClient.${name}).toHaveBeenCalledWith(input);
      });
    });
  });`;

    return `${handlerTypesCheck}${mockImplementationTest}`;
  })
  .join('\n')}
});
`;

  // Write the test file
  const testFilePath = path.join(outputDir, 'apiClient.test.ts');
  fs.writeFileSync(testFilePath, testContent);
  
  // Generate a Jest config that uses the setup file
  const jestConfigContent = `
// Auto-generated Jest config for API client tests
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['./jest.setup.ts'],
  testMatch: ['**/*.test.ts'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest'
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};
`;
  
  fs.writeFileSync(path.join(outputDir, 'jest.config.js'), jestConfigContent);
  console.log(`Generated Jest config with setup file`);
  
  console.log(`API contract tests generated successfully at ${testFilePath}`);
}